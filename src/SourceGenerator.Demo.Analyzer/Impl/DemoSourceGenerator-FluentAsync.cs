using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Linq;

namespace SourceGenerator.Demo.Analyzer
{
    public partial class DemoSourceGenerator
    {
        private void HandleFluentAsyncMethods(SyntaxReceiver receiver, GeneratorExecutionContext context)
        {
            var lookup = receiver.Methods.ToLookup(x => x.IsExtensionMethod
                ? x.Parameters[0].Type
                : x.ContainingSymbol, x => x,
                SymbolEqualityComparer.Default);

            foreach (var lookupGroup in lookup)
            {
                GenerateFluentAsyncExtensions(lookupGroup.Key as INamedTypeSymbol, lookupGroup.ToArray(), context);
            }
        }

        private void GenerateFluentAsyncExtensions(INamedTypeSymbol classSymbol, IMethodSymbol[] methods, GeneratorExecutionContext context)
        {
            var taskType = context.Compilation.GetTypeByMetadataName($"System.Threading.Tasks.Task`1");
            var entityTaskType = taskType.Construct(classSymbol);

            StringBuilder sb = new StringBuilder($@"// <auto-generated />

namespace {classSymbol.ContainingNamespace}
{{
    public static partial class {classSymbol.Name}Extensions
    {{");
            foreach (var method in methods.Where(x => x.MethodKind == MethodKind.Ordinary
                    && x.ReturnType.ToString() == entityTaskType.ToString()))
            {
                // Need a better way of handling this, but because the CoreAsync methods
                // are also dynamically generated, we have to handle these expecting
                // the new public async method will be there in the end
                var parameters = method.Parameters.Skip(method.IsExtensionMethod ? 1 : 0).Where(x => x.Name != "sync").ToList();
                var methodName = method.Name.Replace("CoreAsync", "Async");

                sb.Append($@"
        public static async {entityTaskType.GetFullyQualifiedName()} {methodName}{ConstructTypeParamsString(method)}({ConstructParamsString($"this {entityTaskType.GetFullyQualifiedName()} task", parameters)}) {ConstructTypeParamConstraintsString(method, 12)}
            => await (await task).{methodName}{ConstructTypeParamsString(method)}({ConstructParamsAsArgsString(parameters)});
");

            }

            sb.Append($@"
    }}
}}
");

            // Code generation goes here
            context.AddSource($"{classSymbol.Name}Extensions-FluentAsync.generated.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }
}
